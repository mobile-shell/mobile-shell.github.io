<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Mosh: the mobile shell</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mobile shell that supports roaming and intelligent local echo. Like SSH secure shell, but allows mobility and more responsive and robust.">
    <meta name="author" content="Keith Winstein <mosh-devel@mit.edu>">

    <!-- Le styles -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .callout {
      }
      .hero-titles {
        padding-bottom: 5%;
      }
      .logo {
        padding: 8px;
      }
      .prelike {
      display: block;
      padding: 8.5px;
      margin: 0 0 9px;
      font-size: 12.025px;
      line-height: 18px;
      background-color: #f5f5f5;
      border: 1px solid #ccc;
      border: 1px solid rgba(0, 0, 0, 0.15);
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      border-radius: 4px;
      word-break: break-all;
      word-wrap: break-word;
      }
    </style>
    <link href="assets/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="assets/ico/apple-touch-icon-57-precomposed.png">

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-30270105-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>

  </head>

  <body data-spy="scroll">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="#">Mosh</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="#about">About</a></li>
              <li><a href="#getting">Getting Mosh</a></li>
              <li><a href="#usage">Usage</a></li>
              <li><a href="#techinfo">Technical Info</a></li>
              <li><a href="#faq">FAQ</a></li>
              <li><a href="#lists">Mailing Lists</a></li>
              <li><a href="https://github.com/keithw/mosh">Mosh on GitHub</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container">

      <section id="about">
      <div class="hero-unit">
	<p>
	<div class="row">
	<div class="span5">
        <p><h1>Mosh</h1>
	<h2>(mobile shell)</h2></p>
          <p>Remote terminal application that
        allows <strong class="callout">roaming</strong>, supports <strong class="callout">intermittent
        connectivity</strong>, and provides intelligent
	<strong class="callout">local echo</strong> and line editing of user keystrokes.</p>
	  <p>Mosh is like SSH, but more robust and
	responsive &mdash; especially over wireless or cross-country
	links and ones with packet loss.</p>
	  <p>Mosh is free software, available for GNU/Linux and Mac OS X.</p>
	</div><div class="span5"><img src="mosh.png" style="max-width:120%;"></div>
	</div>
	</p>

        <p><a class="btn btn-primary btn-large" href="#getting">Getting Mosh &raquo;</a></p>
      </div>

      <div class="row">

        <div class="span4">
          <h2 class="callout">Change IP. Stay connected.</h2>
          <p>Mosh automatically roams as you move between Internet
          connections. Use Wi-Fi on the train, Ethernet in a hotel,
          and LTE on a beach: you'll stay logged in. Most network
          programs lose their connections after roaming &mdash;
          including SSH and AJAX apps like Gmail or Google Talk. Mosh
          is different.</p>
        </div>
        <div class="span4">
          <h2 class="callout">Makes for sweet dreams.</h2>
           <p>With Mosh, you can put your laptop to sleep and wake it
	     up later, keeping your connection intact. If your
	     Internet connection drops, Mosh will warn you &mdash; but
	     the connection resumes when network service
	     comes back.
       </div>
        <div class="span4">
          <h2 class="callout">Get rid of network lag.</h2>
          <p>Mosh gives instant feedback to typing, deleting, and line
	    editing. It predicts the effects of keystrokes locally,
	    even in full-screen programs like emacs and vim. On a bad
	    connection, outstanding predictions are underlined so you
	    won't be misled. Other protocols wait for the server's
	    reply to show your typing, which produces an unpleasant
	    user interface on "laggy" connections.</p>
        </div>
      </div>

      <div class="row">
        <div class="span3">
          <h2 class="callout">No privileged code. No daemon.</h2>
           <p>You don't need to be the superuser to install or run
	     Mosh. The client and server are executables run by an
	     ordinary user and last only for the life of the
	     connection.</p>
        </div>

        <div class="span3">
          <h2 class="callout">Same login method.</h2>
           <p>Mosh doesn't listen on network ports or authenticate
	     users. Users start their sessions with SSH and present
	     the same credentials (e.g. password, public key,
	     keyfob). The <tt>mosh</tt> client logs in to the
	     server via SSH and runs the <tt>mosh-server</tt>
	     remotely.</p>
        </div>

	<div class="span3">
	  <h2 class="callout">Runs inside your terminal, but better.</h2>
	  <p>Mosh is a command-line program, like ssh. You can use it
	  inside xterm, gnome-terminal, urxvt, Terminal.app, iTerm,
	  emacs, screen, or tmux. But mosh was designed from scratch
	  and supports just one character set: UTF-8. It fixes Unicode
	  bugs in other terminals and in SSH.
	</div>

	<div class="span3">
	  <h2 class="callout">Control-C works great.</h2>

	  <p>Unlike SSH, mosh's UDP-based protocol handles packet loss
	    gracefully, and sets the frame rate based on network conditions. Mosh
	    doesn't fill up network buffers, so Control-C always works
	    to halt a runaway process.</p>
	</div>
      </div>
      </section>
      
      <section id="getting">
	<div class="page-header">
	  <h1>Getting Mosh</h1>
	</div>
	
	<div class="row">
	  <div class="span4"><h3 class="callout"><a href="http://www.debian.org"><img class="logo" src="debian.png"></a>Debian GNU/Linux <small>testing, unstable</small><br>
	      <a href="http://www.ubuntu.com"><img class="logo" src="ubuntu.png"></a>Ubuntu <small>12.04 LTS (Precise)</small></h3>
	    <p><pre>$ sudo apt-get install mosh</pre></p>
	  </div>

	  <div class="span5"><h3 class="callout"><a href="http://www.ubuntu.com"><img class="logo" src="ubuntu.png"></a>Ubuntu <small>10.04 LTS or later</small></h3>
	    <p>Available in the <a href="https://help.ubuntu.com/community/UbuntuBackports">backports repository</a> as <tt>mosh</tt>, or:
	      <pre>$ sudo add-apt-repository keithw:ppa/mosh
$ sudo apt-get update
$ sudo apt-get install mosh</pre></p>
	  </div>

	  <div class="span3"><h3 class="callout"><a href="http://www.fedoraproject.org"><img class="logo" src="fedora.png"></a>Fedora <small>15 or later</small></h3>
	    <p><pre>$ sudo yum install mosh</pre></p>
	  </div>
	</div>

	<div class="row">
	  <div class="span4"><h3 class="callout"><a href="http://www.apple.com"><img class="logo" src="macosx.png"></a>OS X <small>10.5 or later</small></h3>
	    <p><div class="prelike">Install <a><img src="dmg.png"> mosh-1.1.3.dmg</a>.</div></p>
	  </div>

	  <div class="span4"><h3 class="callout"><a href="http://www.macports.org"><img class="logo" src="macports.png"></a>MacPorts <small>OS X 10.5 or later</small></h3>
	    <p><pre>$ sudo port install mosh</pre></p>
	  </div>
	  
	  <div class="span4"><h3 class="callout"><a href="http://mxcl.github.com/homebrew/">Homebrew</a> <small>OS X 10.6 or later</small></h3>
	    <p><pre>$ brew install mobile-shell</pre></p>
	  </div>
	</div>

	<small><i>Operating system logos are trademarks or registered trademarks and are displayed for identification
only. The vendors shown aren't affiliated with and haven't endorsed Mosh.</i></small>

	<p><h2>Building from source</h2></p>

        <div class="row">

	  <div class="span4">
	    <h3 class="callout">Dependencies</h3><br>
	    <table class="table table-striped" style="width: 100%;">
              <thead><tr><th>Name</th><th>Typical package</th></tr></thead>
              <tr class="deps"><td><a href="http://code.google.com/p/protobuf/">Protocol Buffers</a></td><td>protobuf-compiler, libprotobuf-dev</td></tr>
              <tr><td><a href="http://www.boost.org">Boost</a></td>
                <td>libboost-dev</td></tr>
              <tr><td>utempter</td><td>libutempter-dev</td></tr>
              <tr><td>ncurses</td><td>libncurses5-dev</td></tr>
              <tr><td>zlib</td><td>zlib1g-dev</td></tr>
	    </table>
	  </div>

	  <div class="span3">
	    <h3 class="callout">Latest release</h3><br>
	    <p>Extract
              <a href="https://github.com/downloads/keithw/mosh/mosh-1.1.3.tar.gz">mosh-1.1.3.tar.gz</a>,
              then</p>
<pre>$ cd mosh-1.1.3
$ ./configure
$ make
# make install</pre>
	  </div>

	  <div class="span5">
	    <h3 class="callout">Compiling from Git</h3><br>
	    <p><pre>$ git clone <a href="https://github.com/keithw/mosh">https://github.com/keithw/mosh</a>
$ cd mosh
$ ./autogen.sh
$ ./configure
$ make
# make install</pre></p>
	  </div>
	</div>
      </section>

      <section id="usage">
	<div class="page-header">
	  <h1>Usage</h1>
	</div>

	<p><h3 class="callout">Replaces interactive SSH. Instant keystroke response, robust to roaming. <small>But you'll need working UDP.</small></h3></p>

	<div class="row">
	  <div class="well span3 offset1">
	    <h2 class="callout" style="color: darkblue;">Typical usage</h2>
	    <p><pre>$ mosh <i>chewbacca.norad.mil</i></pre></p>
	    <p>Mosh will log the user in via SSH, then start a connection on a UDP port between 60000 and 61000.</p>
	  </div>

	  <div class="span3 offset1">
	    <h3 class="callout">Different username</h3>
	    <p><pre>$ mosh <b>potus@</b><i>ackbar.bls.gov</i></pre></p>
	  </div>

	  <div class="span3">
	    <h3 class="callout">Particular port</h3>
	    <p><pre>$ mosh <b>-p 1234</b> <i>darth</i></pre></p>
	    <p>If the server is behind a port-forwarder or NAT, a particular UDP port can be requested.</p>
	  </div>
	</div>

	<p></p>

	<div class="row">
	  <div class="span4">
	    <h3 class="callout">Server binary outside path</h3>
	    <p><pre>$ mosh <b>--server=/tmp/mosh-server</b> <i>r2d2</i></pre></p>
	    <p>The user can specify an alternate path for the <code>mosh-server</code> on the remote host. The server binary can even
	      be installed in the user's home directory.</p>
	  </div>

	  <div class="span4">
	    <h3 class="callout">Disable instant echo</h3>
	    <p><pre>$ mosh <b>--predict=never</b> <i>niennunb</i></pre></p>
	    <p>The <code>-n</code> switch is a synonym. By contrast,
	    passing <code style="white-space: nowrap;">--predict=always</code> or <code>-a</code>
	    will enable instant local echo even on low-delay
	    links.</p>
	  </div>

	  <div class="span4">
	    <h3 class="callout">With a command</h3>
	    <p><pre>$ mosh <i>pello</i> <b>-- screen -dr</b></pre></p>
	    <p>This reattaches to a long-running screen session.</p>
	  </div>
	</div>

	<h3 class="callout">Ending the connection</h3>

	<p>Normally, <tt>logout</tt> or <tt>exit</tt> on the remote host will close
	  the session. Mosh accepts the escape sequence <code>Ctrl-^
	  .</code>  (typically typed with Control-Shift-6, then a
	  period) to end the connection forcibly. To send a
	  literal Ctrl-^, type <code>Ctrl-^ ^</code>.</p>

	<h3 class="callout">Not yet supported, but on the roadmap</h3>

	<ul>
	  <li>X11 forwarding

	  <li>IPv6-only hosts or networks

	  <li>Android client
	</ul>

	<h3 class="callout">Manual</h3>

	<p>More details can be found in
	the <code>mosh(1)</code>, <code>mosh-client(1)</code>,
	and <code>mosh-server(1)</code> manual pages.</p>

      </section>

      <section id="techinfo">
	<div class="page-header">
	  <h1>Technical Info</h1>
	</div>
	

	<h3 class="callout">Mosh at USENIX ATC</h3>

	<p>The <a href="mosh-paper-draft.pdf"><img style="padding: 3px;"
	    src="pdf.png"> Mosh research paper</a> (draft, in press) describes
	    the design and evaluation of Mosh in more detail than you
	    may want. The paper will be presented at the
	  <a href="http://static.usenix.org/event/atc12/">2012 USENIX
	    Annual Technical Conference</a>, to be held June
	    13&ndash;15 in sunny Boston, Mass.</p>

	<div class="well"><h4 callout">&#8220;ISO 2022 locking escape
sequences oh flying spaghetti monster please kill me
now.&#8221; <small>&mdash; actual USENIX peer review on reading the
Mosh paper.</small></h4>

<p></p>

<p><span class="label label-info">Why you should trust Mosh with your remote terminal needs:</span> <i>we
worry about details so obscure, even USENIX reviewers don't want to
hear about them.</i></p></div>

	<h3 class="callout">How Mosh works</h3>

	  <p>Remote-shell protocols traditionally work by conveying a
	  byte-stream from the server to the client, to be interpreted
	  by the client's terminal. (This includes TELNET, RLOGIN, and
	  SSH.)</p>

	  <p>Mosh works differently and at a different layer. With
	    Mosh, the server and client both maintain a snapshot of
	    the current screen state. The problem becomes one of
	    <i>state-synchronization</i>: getting the client to the
	    most recent server-side screen as efficiently as
	    possible.</p>

	  <p>This is accomplished using a new protocol called the
	    State Synchronization Protocol, for which Mosh is the
	    first application. SSP runs over UDP, synchronizing the
	    state of any object from one host to another. Datagrams
	    are encrypted and authenticated
	    using <a href="http://www.cs.ucdavis.edu/~rogaway/ocb/">AES-128
	    in OCB mode</a>. While SSP takes care of the networking
	    protocol, it is the implementation of the object being
	    synchronized that defines the ultimate semantics of the
	    protocol.</p>

	  <p>Roaming with SSP becomes easy: the client sends datagrams
	    to the server with increasing sequence numbers, including
	    a heartbeat at least once every three seconds. Every time
	    the server receives an authentic packet from the client
	    with a sequence number higher than any it has previously
	    received, the IP source address of that packet becomes the
	    server's new target for its outgoing packets. By doing
	    roaming "statelessly" in this manner, roaming works in and
	    out of NATs, even ones that may themselves be
	    roaming. Roaming works even when the client is not aware
	    that its Internet-visible IP address has changed. The
	    heartbeats allow Mosh to inform the user when it hasn't
	    heard from the server in a while (unlike SSH, where users
	    may be unaware of a dropped connection until they try to
	    type).</p>

	  <p>Mosh runs two copies of SSP, one in each direction of the
	    connection. The connection from client to server
	    synchronizes an object that represents the keys typed by
	    the user, and with TCP-like semantics. The connection from
	    server to client synchronizes an object that represent the
	    current screen state, and the goal is always to convey the
	    client to the most recent server-side state, possibly
	  skipping intermediate frames.</p>

	  <p>Because SSP works at the object layer and can control the
	    rate of synchronization (in other words, the frame rate),
	    it does not need to send every byte it receives from the
	    application. That means Mosh can regulate the frames so as
	    not to fill up network buffers, retaining the
	    responsiveness of the connection and making sure Control-C
	    always works quickly. Protocols that must send every byte
	    can't do this.</p>

	  <p class="well">One benefit of working at the terminal layer
	    was the opportunity to build a clean UTF-8 terminal
	    emulator from scratch. Mosh fixes several Unicode bugs in
	    existing terminals and in SSH, and was designed as a fresh
	    start to try to be robust and correct even for
	    pathological inputs. Unlike other terminals that use ISO
	    2022 locking sequences, Mosh will never get stuck in
	    hieroglyphs.</p>

	  <p>The other major benefit of working at the
	    terminal-emulation layer is that the Mosh client is free
	    to scribble on the local screen without lasting
	    consequence. We use this to implement intelligent local
	    echo. The client runs a predictive model in the background
	    of the server's behavior, hypothesizing that each
	    keystroke will be echoed at the cursor location and that
	    the backspace and left- and right-arrow keys will have
	    their traditional effect. But only when a predition is
	    confirmed by the server are these effects actually shown
	    to the user. (In addition, by default predictions are only
	    displayed on high-delay connections or during a network
	    "glitch.") Predictions are done in "epochs," so when the
	    user does something that might alter the echo behavior
	    &mdash; like hit ESC or carriage return or an up- or
	    down-arrow &mdash; Mosh goes back into making background
	    predictions until a prediction from the new batch can be
	    confirmed as correct.</p>

	  <p>Thus, unlike previous attempts at local echo with TELNET
	    and RLOGIN, Mosh's local echo can be used everywhere, even
	    in full-screen programs like emacs and vi.</p>

      </section>

    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/bootstrap.min.js"></script>
  </body>
</html>
